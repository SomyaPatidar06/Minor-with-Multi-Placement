{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Multi-Object AR Studio</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    /* Custom AR Button Style */
    #ARButton {
      background-color: #964b00 !important; 
      color: white !important;
      border-radius: 20px !important;
      opacity: 1 !important; 
    }
    /* UI Overlay - Moved to TOP to avoid AR Button overlap */
    #overlay {
      position: absolute;
      top: 20px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      pointer-events: none;
      z-index: 2000;
    }

    .ui-row {
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }

    .ui-element {
      background: rgba(20, 20, 20, 0.85);
      padding: 10px 16px;
      border-radius: 30px;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    select {
      background: transparent;
      color: white;
      border: none;
      padding: 5px;
      font-size: 16px;
      outline: none;
      font-weight: 500;
      min-width: 120px;
    }

    option {
      background: #222;
    }

    button {
      background: #e53935;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:active {
      transform: scale(0.95);
      background: #c62828;
    }

    #info {
      display: none;
    }

    #debug {
      position: absolute;
      bottom: 80px;
      left: 0;
      width: 100%;
      text-align: center;
      color: #ffeb3b;
      pointer-events: none;
      font-size: 14px;
      text-shadow: 1px 1px 2px black;
      font-weight: bold;
      z-index: 1000;
    }
  </style>
</head>

<body>

  <div id="info">1 Finger: Move | 2 Fingers: Rotate/Scale</div>
  <div id="debug"></div>

  <div id="overlay">
    <!-- Controls Row -->
    <div class="ui-row">
      <div class="ui-element">
        <select id="model-select">
          <option value="{% static 'models/Sofaa.glb' %}">Sofa</option>
          <option value="{% static 'models/Chair_2.glb' %}">Chair</option>
          <option value="{% static 'models/table.glb' %}">Table</option>
          <option value="{% static 'models/Lamp.glb' %}">Floor Lamp</option>
        </select>
      </div>
    </div>

    <!-- Action Row -->
    <div class="ui-row">
      <button id="delete-btn" style="background:#c00; display:none;">Delete Selected</button>
    </div>
  </div>

  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let container;
    let camera, scene, renderer;
    let controller;

    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    const loader = new GLTFLoader();
    let currentModelUrl = document.getElementById('model-select').value;

    // Interaction State
    let placedObjects = [];
    let selectedObject = null;
    let selectionBox = null;

    // Gesture State
    const touchData = {
      startDist: 0,
      startAngle: 0,
      startScale: new THREE.Vector3(),
      startRotation: 0,
      isPinching: false,
      isDragging: false,
      wasGesture: false, // Flag to prevent placement after a gesture
      didHitObjectOrDeselected: false // Flag to prevent placement if we just selected/deselected
    };

    const raycaster = new THREE.Raycaster();
    const touchVector = new THREE.Vector2();

    // UI blocking flag
    let isTouchingUI = false;

    init();
    animate();

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      // Prevent context menu (long press)
      window.addEventListener('contextmenu', function (e) { e.preventDefault(); });

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      // AR Button
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      }));

      // Controller
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Reticle
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xf3c13a })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Selection Box
      selectionBox = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.05, 1),
        new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
      );
      selectionBox.visible = false;
      scene.add(selectionBox);

      window.addEventListener('resize', onWindowResize);

      // --- Touch Listeners ---
      // We use 'beforexrselect' to block WebXR select if touching DOM
      document.body.addEventListener('beforexrselect', (ev) => {
        // If we are touching a UI element, prevent the WebXR select event
        if (isTouchingUI) {
          ev.preventDefault();
        }
      });

      // Track UI touches
      const uiElements = document.querySelectorAll('.ui-element, button, select');
      uiElements.forEach(el => {
        el.addEventListener('touchstart', () => { isTouchingUI = true; });
        el.addEventListener('touchend', () => {
          // Small delay to ensure click finishes before allowing XR
          setTimeout(() => { isTouchingUI = false; }, 100);
        });
        el.addEventListener('mousedown', () => { isTouchingUI = true; });
        el.addEventListener('mouseup', () => { isTouchingUI = false; });
      });

      // Global Touch Listeners for Gestures
      window.addEventListener('touchstart', onTouchStart, { passive: false });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd);

      // UI Logic
      document.getElementById('model-select').addEventListener('change', (e) => {
        currentModelUrl = e.target.value;
        selectObject(null);
      });

      document.getElementById('delete-btn').addEventListener('click', (e) => {
        e.stopPropagation(); // Stop propagation just in case
        if (selectedObject) {
          scene.remove(selectedObject);
          placedObjects = placedObjects.filter(o => o !== selectedObject);
          selectObject(null);
        }
      });
    }

    function onSelect() {
      // This fires on Tap (Touch End)

      // 1. If we were pinching/dragging, IGNORE this tap (it was part of a gesture)
      if (touchData.wasGesture) {
        touchData.wasGesture = false; // Reset
        return;
      }

      // 2. If we just selected or deselected an object in touchStart, IGNORE this tap.
      //    This prevents "cloning" when we tap an object (selects it) or tap near it (deselects it).
      if (touchData.didHitObjectOrDeselected) {
        touchData.didHitObjectOrDeselected = false; // Reset
        return;
      }

      // 3. If we are touching UI, IGNORE (should be handled by beforexrselect, but double check)
      if (isTouchingUI) return;

      // 4. Place object if reticle is visible
      if (reticle.visible && !selectedObject) {
        placeModel();
      }
    }

    function placeModel() {
      loader.load(currentModelUrl, function (gltf) {
        const model = gltf.scene;
        reticle.matrix.decompose(model.position, model.quaternion, model.scale);

        // Auto-scale logic: Normalize to ~0.5 meters max dimension
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);

        // Target size: 0.5m (50cm)
        // This ensures all models start at a manageable size regardless of export units
        if (maxDim > 0) {
          const scaleFactor = 0.5 / maxDim;
          model.scale.setScalar(scaleFactor);
        } else {
          model.scale.set(0.1, 0.1, 0.1); // Fallback
        }

        scene.add(model);
        placedObjects.push(model);
        selectObject(model);
      });
    }

    function selectObject(obj) {
      selectedObject = obj;
      const delBtn = document.getElementById('delete-btn');

      if (obj) {
        selectionBox.visible = true;
        selectionBox.position.copy(obj.position);
        delBtn.style.display = 'block';
        document.getElementById('debug').textContent = "Selected";
      } else {
        selectionBox.visible = false;
        delBtn.style.display = 'none';
        document.getElementById('debug').textContent = "";
      }
    }

    function onTouchStart(event) {
      if (isTouchingUI) return; // Ignore scene touches if on UI

      if (event.touches.length === 1) {
        touchData.isDragging = false;
        touchData.wasGesture = false;
        touchData.didHitObjectOrDeselected = false;

        // Raycast for selection
        touchVector.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        touchVector.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(touchVector, camera);

        const intersects = raycaster.intersectObjects(placedObjects, true);
        if (intersects.length > 0) {
          let hitObj = intersects[0].object;
          while (hitObj.parent && !placedObjects.includes(hitObj)) {
            hitObj = hitObj.parent;
          }
          if (placedObjects.includes(hitObj)) {
            selectObject(hitObj);
            touchData.didHitObjectOrDeselected = true; // We hit something, so don't place
          }
        } else {
          // Tapped empty space. 
          // If we have an object selected, deselect it.
          if (selectedObject) {
            selectObject(null);
            touchData.didHitObjectOrDeselected = true; // We deselected, so don't place in this tap
          }
        }
      }

      if (event.touches.length === 2 && selectedObject) {
        touchData.isPinching = true;
        touchData.wasGesture = true;

        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        touchData.startDist = Math.sqrt(dx * dx + dy * dy);
        touchData.startScale.copy(selectedObject.scale);
        touchData.startAngle = Math.atan2(dy, dx);
        touchData.startRotation = selectedObject.rotation.y;
      }
    }

    function onTouchMove(event) {
      if (isTouchingUI) return;

      if (selectedObject) {
        // 1 Finger -> Drag
        if (event.touches.length === 1) {
          // Mark as dragging so we don't treat as tap
          touchData.isDragging = true;
          touchData.wasGesture = true;

          if (reticle.visible) {
            const p = new THREE.Vector3();
            const q = new THREE.Quaternion();
            const s = new THREE.Vector3();
            reticle.matrix.decompose(p, q, s);
            selectedObject.position.lerp(p, 0.2);
            selectionBox.position.copy(selectedObject.position);
          }
        }

        // 2 Fingers -> Scale/Rotate
        if (event.touches.length === 2) {
          const dx = event.touches[0].clientX - event.touches[1].clientX;
          const dy = event.touches[0].clientY - event.touches[1].clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);

          const scaleFactor = dist / touchData.startDist;
          selectedObject.scale.copy(touchData.startScale).multiplyScalar(scaleFactor);

          const angleDelta = angle - touchData.startAngle;
          selectedObject.rotation.y = touchData.startRotation + angleDelta;

          selectionBox.position.copy(selectedObject.position);
        }
      }
    }

    function onTouchEnd(event) {
      if (event.touches.length < 2) {
        touchData.isPinching = false;
      }
      // Note: onSelect fires AFTER touchEnd.
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (hitTestSourceRequested === false) {
          session.requestReferenceSpace('viewer').then(function (referenceSpace) {
            session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', function () {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>